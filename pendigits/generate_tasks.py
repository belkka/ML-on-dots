# -*- coding: utf-8 -*-
import codecs


filename = u"{alg} ({init}).txt"
template = u"""# Кластеризация рукописных цифр. {alg} ({init})

Дан список векторов размерности 16, определяющих оцифрованные изображения рукописных цифр 0, 1, ..., 9. Разбейте их на 10 кластеров с помощью алгоритма {alg}. 

{alg_description}

Инициализацию центров кластеров в этой задаче проводите с помощью метода {init}.

{init_description}

Аккуратность полученной кластеризации должна быть не меньше 70%.
Аккуратность это процент цифровых изображений цифр, помещенных в кластеры, где большинство цифровых изображений соответствует другой цифре


## Формат входных данных:
Файл содержит некоторое количество строк с описанием векторов.
В строке i содержится описание вектора i - 1 (нумерация векторов начинается с 0), которое состоит из 16 целых чисел величиной 0 до 100. Соседние числа разделёны пробелами.
Пустая строка обозначает конец входых данных.


## Формат выходных данных:
В строке i должны быть номера всех векторов, отнесённых к кластеру i, где i изменяется от 1 до 10.
Нумерация векторов начинается с 0.


## Замечание
Единственный тест будет засчитан, если на нём алгоритм покажет аккуратность выше 70%
Аккуратность вычисляется следующим образом: в соответствии с настоящими данными о изображённых цифрах тестовая система определит сколько изображений каждой цифры попало в каждый кластер пользовательского решения. Затем между кластерами и цифрами поставится биективное соответствие так, чтобы общее количество "правильно" классифицированных изображений было максимальным. Доля этих изображений среди всех и есть аккуратность.

Например, пусть изображения разных цифр были разбиты решением на кластеры в соответствии с таблицей (проверяющая система будет иметь информацию о настоящих цифрах на изображениях):

              0    1    2    3    4    5    6    7    8    9

Кластер 1:    0   61   53    0    0    0    0  251   77    0
Кластер 2:    3  498    5   16   16    0    0   90    1   62
Кластер 3:  717    0    0    0    0    0    0    0  100    5
Кластер 4:   46   14    0    0   23   65  716    0    5    3
Кластер 5:    1    0    0    0    0    3    0    0  230    0
Кластер 6:    1   71    0  701    2  196    0   35   59  484
Кластер 7:    0  135  722    1    2    0    1    2    6   12
Кластер 8:    1    0    0    0    0  456    1    1  241    0
Кластер 9:    0    0    0    0    0    0    0  399    0    0
Кластер 10:  11    0    0    1  737    0    2    0    0  153

Несмотря на то, что в кластерах 1 и 9 наибольшее число изображений содержит цифру "7", одному из них в соответствие поставится какая-то другая цифра так, чтобы общее число "правильно" классифицированных изображений было максимальным. Изображение считается "правильно" классифицированным, если цифра на нём совпадает с цифрой, поставленной в соответствие кластеру, в который это изображение попало.

"""


algs = {
    u"k-средних":
u"""Основная идея алгоритма k-средних заключается в том, что на каждой итерации перевычисляется центр масс для каждого кластера, полученного на предыдущем шаге, затем векторы разбиваются на кластеры вновь в соответствии с тем, какой из новых центров оказался ближе по выбранной метрике.
Алгоритм завершается, когда на какой-то итерации не происходит изменения центра масс кластеров. Это происходит за конечное число итераций.""",

    u"k-медиан":
u"""Основная идея алгоритма k-медиан заключается в том, что на каждой итерации перевычисляется медиана для каждого кластера, полученного на предыдущем шаге, затем векторы разбиваются на кластеры вновь в соответствии с тем, какая из новых медиан оказалась ближе по выбранной метрике.
Алгоритм завершается, когда на какой-то итерации не происходит изменения медиан кластеров. Это происходит за конечное число итераций."""
}

inits = {
    u"forgy method":
u"""Этот метод случайным образом выбирает k элементов из набора данных и назначает их в качестве начальных центров кластеров""",

    u"random partition":
u"""Этот метод случайным образом разбивает набор данных на k кластеров и назначает их центры в качестве начальных.""",

    u"k-means++":
u"""Этот метод выбирает начальные центры таким образом:
1. Выбрать первый центр случайным образом (среди всех точек)
2. Для каждой точки найти значение квадрата расстояния до ближайшего центра (из тех, которые уже выбраны)
3. Выбрать из этих точек следующий центр так, чтобы вероятность выбора точки была пропорциональна вычисленному для неё квадрату расстояния.
Это можно сделать следующим образом. На шаге 2 нужно параллельно с расчётом dx² подсчитывать сумму Sum(dx²). После накопления суммы найти значение Rnd=random(0.0,1.0)*Sum. Rnd случайным образом укажет на число из интервала [0; Sum), и нам остаётся только определить, какой точке это соответствует. Для этого нужно снова начать подсчитывать сумму S(dx²) до тех пор, пока сумма не превысит Rnd. Как только это случится, суммирование останавливается, и мы можем взять текущую точку в качестве центра.
При выборе каждого следующего центроида специально следить за тем, чтобы он не совпал с одной из уже выбранных в качестве центроидов точек, не нужно, так как вероятность повторного выбора некоторой точки равна 0.
4. Повторять шаги 2 и 3 до тех пор, пока не будут найдены все необходимые центроиды."""
}

for (alg, alg_des) in algs.iteritems():
    for (init, init_des) in inits.iteritems():
        f = codecs.open(filename.format(alg=alg, init=init), "w", encoding="utf-8")
        text = template.format(alg=alg, init=init, alg_description=alg_des, init_description=init_des)
        #print text
        f.write(text)
        f.close()

